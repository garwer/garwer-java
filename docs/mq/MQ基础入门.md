# mq
> MQ（Message Queue）[消息队列](https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/4751675)，是基础数据结构中“先进先出”的一种数据结构。一般用来解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。



> 什么是分布式
>
> 分布式是若干个独立计算机的集合，这些集合对于用户来说就像是单个相关系统



为何要用消息队列:

通过消息队列、解耦异步削峰，可以更容易的设计分布式架构、



### 特性

```
1.业务无关
2.FIFO先投递先到达
3.容灾:节点动态增删和消息持久化
4.高性能:吞吐量提升，内部通讯效率才会提高
```



### 常用场景

```
订单系统，订单成功需要给用户通知，可以把订单记录通知到短信系统
评论审核
```



### rabbitmq

```
几个概念
exchange:交换机，消息到达服务的第一站，根据分发规则放到指定消息中
三种类型
direct直连:只有消息路由绑定关系一致时，才会把消息发到相应队列
Fanout广播:发到所有队列
topic:主题，根基主题
message:消息体对象，包含消息类型消息id
```



#### 丢消息的三种情况

1.生产者发送过程中丢【事务和confirm(回传ack)机制、同步和异步】

2.rabbitmq受到消息还未消息挂掉了，内存中休息丢【queue持久化，这样即使挂了也会恢复queue的数据】

3.消费者受到后没来得及处理挂掉，以为处理完但实际上是丢了【消费者关闭自动ack改为手动发,确定业务代码处理完之后发一个ack通知】



**怎么保证数据安全**

1.持久化

exchange、queue、消息持久化

```
exchange和queue的durable属性设为true
```



2.ack

持久化保证了出现宕机重启数据不会丢，保证消息的安全性，但可能在消息处理过程中还是有失败的情况，ack机制即解决这个问题

由于发布操作是不返回信息给生产者，如何知道服务器正确接收消息并持久化到硬盘上



发送方确认

```
发消息到rabbitmq第一站就是交换机，rabbitmq是否正确接收消息，依靠它来反馈
```



#### rabbitmq如何保证消息不丢

https://www.cnblogs.com/flyrock/p/8859203.html

```
针对生产者
1.rabbitmq提供事务功能，即生产者开启后如果消息没收到则会异常报错。
事务机制是同步的，提交事务方式会造成阻塞导致吞吐量下降
2.confirm机制。异步的
```

```
rabbitmq:
  publisher-confirms: true
```

```
1.开启confirm
2.开启交换机队列消息持久化
3.ack确认机制，可能消息收到一半消费者挂掉，使用ack机制消费者消费完了还会通知服务端，服务端才把消息从内存删除
4.配置重试次数间隔时间等
5.设置集群镜像模式，将需要的队列做成镜像队列，属于rabbitmq的ha方案
```



#### kafka如何保证消息不丢

kafka会自动提交offset,关闭自动提交offset，在处理完之后手动提交offset，这样可以可以保证数据不会丢，但可能出现重复消费问题。

比如刚刚处理完挂了重头消费，这个时候保证幂等性即可。



kafka的ha机制就是副本机制，每个partion的数据都会同步到其它及其形成多个replica副本，所有副本会选举一个leader出来

```
// 一下配置至少可以保证leader所在的broker发生切换，在leader切换时数据不丢
给topic设置replication.factor参数，保证每个partion至少2个副本
producer设置acks=all，这样保证必须写入所有replica之后才认为是写成功
producer设置retries=MAX 一旦写入失败无限重试
```





enable.auto.commit=false



### mq的高可用









